id,chapter,title,content,,
1,1-1,자료형 인트로,"모든 컴퓨터는 정보를 1과 0으로 이루어진 2진수로 처리합니다. 그 중에서 특히 문자는 2진수로 바뀌어 ASCII, UTF-8등 여러 포멧을 통해 처리하게 됩니다. 예를 들어 ASCII에서 알파벳 A는 숫자 65로 표현하게 됩니다. 그렇다면 컴퓨터는 이진수로 바뀐 65라는 숫자가 알파벳 A를 나타내는지 단순히 숫자 65를 나타내는지 어떻게 알 수 있을까요? 이를 데이터에 표시해 준 것을 자료형이라고 합니다.  
\n 자료형은 컴퓨터가 여러 종류의 데이터를 식별하는 분류입니다. 보통 python의 기초를 다룰 때 숫자형, 문자열, 리스트, 튜플, 딕셔너리, 집합, 불을 배웁니다. 이번 챕터에서는 이들이 무엇이고, 다루기 위한 함수들을 배울 것입니다. 
\n Type()함수를 이용하여 자료형을 쉽게 확인할 수 있습니다. 궁금한 자료형이 있다면 직접 넣어서 확인해보도록 합시다. 

\n\n>>> type(6)	 	# 정수  
\n<type 'int'>  

\n\n>>> type('A') 		# 문자열  
<type 'str'>",,
2,1-2,숫자형,"숫자형은 숫자의 형태로 이루어진 자료형입니다. Python에서는 정수, 실수, 8진수, 16진수등을 지원합니다. 아래가 실제 쓰이는 표현 방식입니다. 

\n\n자료형             표현 
\n정수             1, -365, 0 
\n실수     72.465, 3.64e-8, 3.64E9 
\n8진수       0o253, 0o473355 
\n16진수        0x1464, 0x1 

\n\n 이중에서 실수는 지수표현방식으로 3.64e-8은 3.64*10^(-8), 3.64E9는 3.64*10^9을 의미합니다. 또한 8진수의 앞에는 0o또는 0O를, 16진수 앞에는 0x를 붙여 구분합니다. 


\n\n\n숫자형의 연산자 

\n\n 숫자형은 우리가 흔히 알고 있는 사칙연산을 할 수 있습니다. 다만 나눗셈의 경우에는 추가로 두가지 연산자를 더 지원합니다. 
이전 파이썬2에서는 정수끼리의 나눗셈 결과는 정수만 나왔습니다. 하지만 파이썬3로 오면서 나눗셈의 결과가 실수로 나올 수 있도록 변경되었습니다. 그래서 파이썬3에서는 이전 사양과 동일한 결과가 나오는 //연산자 추가되었습니다. 

\n\n연산자          설명               입력값      출력값 
\n   +       더하기 연산자           1+1          2 
\n   -         빼기 연산자             1-1           0 
\n   *        곱하기 연산자           2*3           6 
\n   /        나누기 연산자           7/2          3.5 
\n  //      나눗셈후 몫 출력         7//2          3 
\n  %   나눗셈 후 나머지 출력     8%3          2 
\n  **      거듭제곱 연산자         2**10       1024 ",,
3,1-3,문자열,"문자열(String)은 단순하게 문자들의 모임으로, 따옴표로 감싸져 있는 값을 의미합니다. Python에서 문자열은 모두 따옴표로 둘러 쌓여 있습니다. 이 때 큰따옴표(“ ”)와 작은따옴표(‘ ‘)를 모두 사용할 수 있는데, 두가지를 사용하는 이유는 문자열 내부에서 큰따옴표와 작은따옴표를 사용하고자 함입니다.  

\n\n this ball is my brother’s ball 

\n\n 이와 같은 문자열을 변수에 저장하려고 합니다. 이 때 작은따옴표를 사용하게 되면 저 문장 안에 있는 작은따옴표로 인해 닫히지 않은 문자열이 형성되어 오류를 출력합니다 

\n\n>>> ball = ‘this ball is my brother’s ball’ 

\n\nFile ""<stdin>"", line 1 
\n    ball = 'thisball is my brother's ball' 
\n                                         ^ 
\nSyntaxError: invalid syntax 

\n\n 이러한 상황에서 큰따옴표로 문자열을 감싸서 표현합니다. 반대의 상황도 동일하게 가능합니다. 

 

\n\n\n\n문자열 함수 

\n\n1) Find, index 

\n\n Find 함수와 index함수는 검색한 문자열이 처음으로 있는 위치를 반환하는 함수입니다. 다만, 만약 검색하고자 하는 문자열이 찾는 문자열에 없을 경우 find 함수는 -1을 반환하지만 index함수는 오류를 발생시킵니다. 

\n\n>>> “abc”.find(‘b’) 
\n1 

\n\n>>> “abc”.index(‘d’) 
\nValueError: substring not found 

\n\n>>>”abc”.find(‘d’) 
\n-1 

 

\n\n\n2) Upper, lower 

\n\n Upper함수와 lower함수는 문자열 전부를 대문자, 혹은 소문자로 변경해줍니다. 

\n\n>>>”Hello World!”.upper() 
\n“HELLO WORLD!” 

\n\n>>>”Hello World!”.lower() 
\n“hello world!” 

 
\n\n\n3)Replace 

\n\n 주어진 문자열 안의 특정한 값을 다른 값으로 치환해줍니다. 문자열에서 일괄적으로 수정할 내용이 있을 경우 유용하게 사용됩니다. 

\n\n>>>”Hello World!”.replace(“World”, “Python”) 
\n‘Hello Python!’ 

 
\n\n\n4)split 

\n\n 괄호 안에 특정 값이 있는 경우 괄호안의 값을 구분자로 하여 문자열을 나누어 뒤에 배울 리스트로 반환합니다. 아무것도 넣어주지 않는다면, 공백을 기준으로 나누어줍니다. 

\n\n>>>”Hello World!”.split() 
\n[‘Hello’, ‘World!’] 

\n\n>>> “a;b;c;d”.split(‘;’) 
\n[‘a’, ‘b’, ‘c’, ‘d’] ",,
4,1-4,리스트,"지금까지는 하나의 변수에 하나의 값만 저장하여 사용하였습니다. 그러나 실제 우리가 코딩을 할 때 모든 값을 변수로 지정하여 저장하려면 시간과 노력이 많이 들어가게 됩니다. 이러한 번거로운 작업을 줄이기 위해 여러 값을 한개의 리스트안에 저장하여 편리하게 사용할 수 있습니다. 
\n 리스트는 []대괄호로 묶고, 각 값을 ,(콤마)로 구분하여 표현합니다. 
\n 리스트 = [값, 값, 값, ...] 
\n 예시로 몇 가지 리스트를 보여드리겠습니다 
\nList1 = [] 
\nList2 = [0, 1] 
\nList3 = [0, 1, 2, ‘python’] 
\nList4 = [0, 1, [‘py’, ‘thon’]] 
\n 이와 같이 리스트 안에는 모든 자료형이 들어갈 수 있으며, 같은 자료형인 리스트도 담을 수 있습니다. 

 
\n\n\n리스트 연산자 

\n\n 리스트도 숫자형, 문자열과 비슷하게 +기호를 사용해서 여러 개의 리스트를 더할 수 있고, *기호를 사용하여 반복된 리스트를 만들 수 있습니다. 

\n\n>>> [1, 2, 3] + [4, 5, 6] 
\n[1, 2, 3, 4, 5, 6] 

\n\n>>> [1, 2] * 3 
\n[1, 2, 1, 2, 1, 2] 

 
\n\n\n1) Append, extend 

\n\n Append 함수와 extend함수는 모두 리스트에 값을 추가할 때 사용합니다. 추가된 값은 리스트의 끝에 저장됩니다. 다만, append함수는 요소를 하나만 추가할 수 있고, extend함수는 여러 요소를 한꺼번에 넣거나 리스트를 합칠 수 있다는 차이점이 있습니다. 

\n\n>>>list = [1, 2, 3] 
\n>>>list.append(4) 
\n>>>list 
\n[1, 2, 3, 4] 

\n\n>>>list.extend([5, 6]) 
\n>>>list 
\n[1, 2, 3, 4, [5, 6]] 
 

\n\n\n2) Sort 

\n\n Sort 함수는 리스트의 요소를 순서대로 정렬해 줍니다. 문자 또한 알파벳 순서로 정렬 할 수 있습니다 

\n\n>>> a = [2, 3, 1, 4] 
\n>>> a.sort() 
\n>>> a 
\n[1, 2, 3, 4] 

\n\n>>> b = [b, a, d, c] 
\n>>>b.sort() 
\n>>> b 
\n[a, b, c, d] 
 

\n\n\n3) Index 

\n\n Index 함수는 리스트에 값이 있다면 그 위치값을 return합니다. 만약 리스트에 값이 존재하지 않는다면 오류를 출력합니다. 

\n\n>>> list = [ 3, 2, 1, 4] 
\n>>> list.index(1) 
\n2 

\n\n>>> list.index(5) 
\nTraceback (most recent call last): 
\n  File ""<stdin>"", line 1, in <module> 
\nValueError: 5 is not in list 

 
\n\n\n4) Insert 

\n\n Insert(a, b) 함수는 리스트의 a위치에 b를 삽입하는 함수입니다. 음수를 입력하면 배열의 끝을 기준으로 처리하게 됩니다. 

\n\n>>> list = [1, 4] 
\n>>> list.insert(1, 2) 
\n>>>list 
\n[1, 2, 4] 

\n\n>>> list.insert(-1,3) 
\n>>>list 
\n[1, 2, 3, 4] 

 
\n\n\n5) Remove 

\n\n Remove 함수는 리스트의 앞에서부터 값을 찾고, 첫번째로 나오는 값을 삭제하는 함수입니다. 한번 실행시에 하나의 값만 삭제합니다. 

\n\n>>> list = [3, 1, 2, 3] 
\n>>>list.remove(3) 
\n>>> list 
\n[1, 2, 3] 

 
\n\n\n6) Pop 

\n\n Pop함수는 리스트의 맨 끝의 값을 return하고 삭제하는 함수입니다. 안에 숫자를 넣게 되면, 그 위치의 값을 return하고 삭제합니다. 

\n\n>>> list = [1, 2, 3, 4] 
\n>>>list.pop() 
\n4 

\n\n>>>list 
\n[1, 2, 3] 

\n\n>>>list.pop(0) 
\n1 

\n\n>>>list 
\n[2, 3] ",,
5,1-5,튜플,"튜플(Tuple)은 리스트와 대부분이 비슷하지만 리스트와 약간의 차이가 있습니다. 
\n 리스트는 [](대괄호)로 둘러싸지만, 튜플은 ()(소괄호)로 둘러싸거나 괄호를 생략하기도 합니다. 튜플과 리스트의 가장 큰 차이점은 리스트와는 다르게 튜플은 내부의 값을 변경할 수 없다는 점입니다. 
\n 이러한 특징 때문에 프로그램이 실행하는 동안 변하면 안되는 값들을 저장할 때 사용하게 됩니다. 이와 반대로 내부의 값을 변동해야 하는 경우에는 리스트를 사용하게 됩니다. 
 

\n\n\n인덱싱과 슬라이싱 

\n\n 우리가 지금까지 배운 리스트, 튜플, 문자열은 모두 값이 연속적으로 저장되는 구조를 가지며, 이러한 구조를 가지는 자료형들을 시퀀스 객체라고 부릅니다. 시퀀스 객체는 모두 인덱싱과 슬라이싱이 가능합니다. 인덱싱(Indexing)이란 무엇인가를 ""가리킨다""는 의미이고, 슬라이싱(Slicing)은 무엇인가를 ""잘라낸다""는 의미입니다. 이 두가지는 시퀀스객체의 구조와 연관이 깊기 때문에 확실하게 아는 것이 중요합니다.  
\n 시퀀스객체의 각 값은 순서가 정해져 있으며, 이 순서를 인덱스라고 합니다. 다음과 같이 시퀀스 객체에 [](대괄호)를 붙이고 대괄호 안에 인덱스를 넣어 해당 위치의 값을 알 수 있습니다. 이를 인덱싱이라고 합니다. 

\n\n>>> a = [41, 83, 63] 
\n>>> a[0] 
\n41 

\n\n>>> a[1] 
\n83 

\n\n>>>a[2] 
\n63 

\n\n 이때 주의 해야할 점은 첫번째 값이 인덱스 0번이라는 것입이다. 따라서 모든 시퀀스객체의 첫번째 값은 a[0]부터 시작하게 됩니다. 


\n\n\n 슬라이싱은 객체의 원하는 부분 일부를 잘라내는 것을 말합니다. [](대괄호)내부에 시작지점의 인덱스와 :(콜론), 끝지점의 인덱스를 넣어 범위를 지정합니다. 이때 시작지점의 값은 포함이 되지만 끝지점의 값은 포함이 되지 않기 때문에 범위를 지정할 때 원하는 끝지점의 인덱스보다 하나 더 큰 값을 넣어야 합니다.  

\n\n>>> a = [1, 2, 3, 4] 
\n\n>>> a[1: 3] 
\n[2, 3] 

\n\n 만약 시작 또는 끝을 문자열의 시작과 끝으로 지정하고 싶다면 그부분을 생략하면 됩니다. 

\n\n>>> a[2:] 
\n[3, 4] ",,
6,1-6,불,"불(boolean) 자료형은 참 또는 거짓이라는 두가지 값 만을 가질 수 있는 자료형입니다. 이 자료형은 주로 조건문의 결과로 사용하며, 나중에 배울 if문이나 while문에서 자주 사용하게 됩니다. 
 
\n\n>>> 2*4 == 8 
\nTrue 

\n\n>>> 4 == 5 
\nFalse 
 
\n\n 그런데 특이하게도 다른 자료형에 대해서 이러한 불 자료형으로 참과 거짓을 구분할 수 있습니다. 

\n\n>>>bool(2) 
\nTrue 

\n\n>>>bool(0) 
\nFalse 

\n\n>>>bool([1, 2]) 
\nTrue 

\n\n>>>bool([]) 
\nFalse 
 
\n\n 이러한 예시에서 알 수 있듯이 값이 비어있는 경우 거짓이 되고, 무언가가 들어가 있으면 참이 됩니다. 숫자의 경우에는 0일때 거짓이고 그 이외의 값은 모두 참이 됩니다.  

\n\n>>> a = [1, 2, 3, 4] 
\n>>> while a: 
\n...	print(a.pop()) 
\n... 
\n4 
\n3 
\n2 
\n1 

\n\n a의 마지막 요소를 끄집어내는 함수이므로 a가 참인 동안(리스트 내에 요소가 존재하는 한) 마지막 요소를 계속해서 끄집어낼 것입니다. 결국 더 이상 끄집어낼 것이 없으면 a가 빈 리스트([ ])가 되어 거짓이 됩다. 따라서 while문에서 조건이 거짓이 되므로 중지됩니다. 위에서 예시는 파이썬 프로그래밍에서 매우 자주 이용하는 기법 중 하나입니다.",,
13,4,파일 읽고 쓰기,"우리는 지금까지 사용자의 입력을 받아서 모니터에 직접 출력하는 경우만 배워왔습니다. 그러나 입력을 받고 출력을 하는 방법은 이것 만이 있는 것이 아닙니다. 이번에는 파일로부터 데이터를 입력 받고 출력하는 방법에 대하여 배워볼 것입니다. 
 

\n\nOpen, close 함수 

\n 우선 파일로부터 입출력을 하기 위해서는 파일을 열어야 합니다. 이를 위한 함수가 open함수입니다. 

\n\n파일 객체 = open(파일경로, 파일 모드) 

\n\n이때 파일 모드는 다음과 같이 3가지가 있습니다. 

\n\n R       기존의 파일을 읽습니다 
\n W      기존 파일의 내용을 제거하고, 처음부터 씁니다 
\n A       기존 파일에 내용을 추가합니다 

\n\n 파일경로의 기본값은 프로그램을 실행시키는 위치이며, 만약 파일이름만 넣는다면 프로그램을 실행한 디렉토리에 새로운 파일이 만들어 질 것입니다. 

\n\n 예를 들어 프로그램이 실행한 위치에 read.txt라는 파일을 만들고 싶다면 f = open(“read.txt”, ‘w’) 
\n C:\Users 라는 디렉토리에 read.txt라는 파일을 만들고 싶다면 

\n\nF = open(“C:\Users\read.txt”, ‘w’) 

\n\n이런 식으로 코드를 작성하면 됩니다. 

\n그리고 파일을 열어 사용한 후에 꼭 닫아주는 작업이 필요합니다. 이 닫아주는 작업을 하는 함수가 close 함수입니다. 프로그램을 종료할 때 파이썬 프로그램이 열려 있는 파일의 객체를 자동으로 닫아주어 굳이 사용하지 않아도 됩니다. 하지만, 파일을 닫지 않고 다시 사용하려 하면 오류가 발생하기 때문에 파일을 열어 작업한 후에는 close 함수를 사용하는 습관을 들이는 것이 좋습니다.  

 

\n\n\nWrite 함수 

\n\n이제 파일을 열었으니 원하는 내용을 적어야 합니다. Write 함수는 내부에 담겨 있는 값을 한번에 파일에 적어줍니다. 

\n\nF = open(“test.txt”, ‘w’)	           //내용을 쓸것이기 때문에 w로 엽니다. 
\nF.write(“111\n”)			           //1을 쓰고 줄을 바꿉니다 
\nData = “222\n333” 
\nF.write(Data)			           //Data안의 값을 파일에 적습니다 
\nF.close() 

\n\n위의 코드를 IDE에서 작성하여 실행시켜보면  
\n111 
\n222 
\n333 
\n 이러한 내용이 파일에 담겨있는 것을 확인할 수 있습니다. 

 

\n\n\nRead, readline 함수 

\n\n방금 우리가 작성한 파일을 한번 읽어보도록 하겠습니다. 읽기 위해서는 흔히 read 함수와 readline 함수를 사용합니다. 둘의 차이점이라면 read 함수는 한글자씩 읽는 반면에 readline 함수는 한줄씩 읽습니다. 

\nF = open(“test.txt”, ‘r’) 
\nA = f.read() 
\nPrint(c) 
\nf.close() 
\n\n1 
 
\n\nF = open(“test.txt”, ‘r’) 
\nA = f.readline() 
\nPrint(a) 
\n\n111 

 
\n\n만약 파일을 전부 읽고싶다면 다음과 같이 작성하면 됩니다. 

 
\n\nF = open(“test.txt, ‘r’)		//내용을 읽을것이기 때문에 r로 엽니다. 
\nWhile True: 
\n    C = f.read()                     //파일의 글자를 읽습니다 

\n    If c == ‘’;		 
\n        break	                       //만약 읽은 글자가 파일의 끝이면 읽기를 멈춥니다 
\n    Print(c, end=’’) 
\nf.close() 


\n\n1 
\n22 
\n333 ",,
,,,, , 
,,,,,
